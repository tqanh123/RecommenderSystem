<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>TenrecRec - Demo System</title>
<script src="https://cdn.tailwindcss.com"></script>

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,1,0" rel="stylesheet">
<style>
    body { font-family: 'Inter', sans-serif; }
    .scroll-hide::-webkit-scrollbar { display: none; }
    .scroll-hide { -ms-overflow-style: none; scrollbar-width: none; }
</style>
</head>
<body class="bg-slate-50 text-slate-800 h-screen flex overflow-hidden">
<!-- Sidebar -->
<aside class="w-64 bg-white border-r border-slate-200 flex-shrink-0 flex flex-col z-20 shadow-sm hidden md:flex">
<div class="p-6 border-b border-slate-100">
    <div class="flex items-center gap-2 text-blue-600 font-bold text-xl">
        <span class="material-symbols-outlined text-3xl">hub</span>
        <span>TenrecRec</span>
    </div>
    <p class="text-xs text-slate-400 mt-1">LightGCN Demo System</p>
</div>
<nav class="flex-1 overflow-y-auto p-4 space-y-1">
    <button class="w-full flex items-center gap-3 px-3 py-2 text-sm font-medium rounded-md bg-blue-50 text-blue-700" onclick="alert('Demo: Feed Active')">
        <span class="material-symbols-outlined text-xl">dynamic_feed</span>
        <span>For You (Feed)</span>
    </button>
    <button class="w-full flex items-center gap-3 px-3 py-2 text-sm font-medium text-slate-600 hover:bg-slate-50" onclick="alert('Demo: Data View')">
        <span class="material-symbols-outlined text-xl">database</span>
        <span>Dataset Manager</span>
    </button>
</nav>
</aside>

<!-- Main Content Area -->
<div class="flex-1 flex flex-col h-full">
<!-- Main -->
<main class="flex-1 flex h-full relative overflow-hidden">
    <!-- Feed Column -->
    <div class="flex-1 flex flex-col overflow-hidden border-r border-slate-200">
    <header class="h-16 bg-white border-b border-slate-200 flex items-center justify-between px-6">
        <div class="relative w-96">
            <span class="material-symbols-outlined absolute left-3 top-2.5 text-slate-400">search</span>
            <input class="w-full pl-10 pr-4 py-2 rounded-lg border border-slate-200 bg-slate-50 text-sm" placeholder="Search items..." type="text"/>
        </div>
        
        <div class="flex items-center gap-4">
            <!-- User Info -->
            <div id="user-info" class="flex items-center gap-2 px-3 py-1.5 rounded-lg bg-blue-50 border border-blue-200">
                <span class="material-symbols-outlined text-blue-600">account_circle</span>
                <span id="username-display" class="text-sm font-medium text-blue-700">Loading...</span>
            </div>
            
            <!-- Logout Button -->
            <button onclick="logout()" class="px-3 py-1.5 text-sm font-medium text-slate-600 hover:text-slate-800 hover:bg-slate-100 rounded-lg transition">
                <span class="material-symbols-outlined text-xl">logout</span>
            </button>
            
            <!-- Status -->
            <div class="flex items-center gap-2 px-3 py-1 rounded-full bg-green-50 text-green-700 text-xs font-medium border border-green-200">
                <span class="w-2 h-2 rounded-full bg-green-500 animate-pulse"></span> LightGCN Ready
            </div>
        </div>
    </header>
    <div class="flex-1 overflow-y-auto bg-slate-50 p-6" id="feed-container">
        <!-- Hero -->
        <div class="relative rounded-2xl overflow-hidden bg-indigo-900 text-white mb-8 shadow-lg p-8">
            <h2 class="text-3xl font-bold mb-2">Recommended For You</h2>
            <p class="text-indigo-200">Personalized recommendations based on your preferences (excluding items you've already interacted with).</p>
        </div>
        
        <!-- Loading State -->
        <div id="loading" class="text-center py-8">
            <div class="inline-block w-8 h-8 border-4 border-blue-600 border-t-transparent rounded-full animate-spin"></div>
            <p class="mt-2 text-slate-600">Loading items from database...</p>
        </div>
        
        <!-- Items Grid -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 hidden" id="items-grid"></div>
        
        <!-- Error State -->
        <div id="error" class="hidden bg-red-50 border border-red-200 rounded-lg p-4 text-red-700">
            <p class="font-bold">Error loading items</p>
            <p id="error-message" class="text-sm mt-1"></p>
        </div>
    </div>
    </div>

    <!-- Embedding Visualization Panel -->
    <aside class="w-96 bg-white flex-shrink-0 flex flex-col shadow-lg">
        <div class="h-16 border-b border-slate-200 flex items-center justify-between px-4">
            <div class="flex items-center gap-2">
                <span class="material-symbols-outlined text-purple-600">scatter_plot</span>
                <span class="font-semibold text-slate-800">Embedding Space</span>
            </div>
            <button onclick="clearVisualization()" class="text-xs text-slate-500 hover:text-slate-700 px-2 py-1 rounded hover:bg-slate-100">
                Clear
            </button>
        </div>
        
        <div class="flex-1 p-4 overflow-hidden flex flex-col">
            <!-- Canvas Container -->
            <div class="flex-1 bg-slate-50 rounded-lg border border-slate-200 relative overflow-hidden">
                <canvas id="embedding-canvas" class="w-full h-full"></canvas>
            </div>
            
            <!-- Legend -->
            <div class="mt-4 p-3 bg-slate-50 rounded-lg border border-slate-200 text-xs">
                <div class="font-semibold text-slate-700 mb-2">Legend:</div>
                <div class="space-y-1.5">
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3 rounded-full bg-blue-500"></div>
                        <span class="text-slate-600">You (Current User)</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3 rounded-full bg-slate-400"></div>
                        <span class="text-slate-600">Other Users</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3 rounded-full bg-amber-500"></div>
                        <span class="text-slate-600">Interacted Items</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3 rounded-full bg-green-500"></div>
                        <span class="text-slate-600">Top 10 Closest Items</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-2 h-2 bg-pink-400"></div>
                        <span class="text-slate-600">Your Interactions</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-2 h-2 bg-pink-200"></div>
                        <span class="text-slate-600">Others' Interactions</span>
                    </div>
                </div>
            </div>
            
            <!-- Stats -->
            <div id="viz-stats" class="mt-3 p-3 bg-blue-50 rounded-lg border border-blue-200 text-xs">
                <div class="font-semibold text-blue-900 mb-1">Your Interactions: <span id="interaction-count">0</span></div>
                <div class="text-blue-700">Other Users: <span id="other-users-count">0</span></div>
                <div class="text-blue-700">Items visualized: <span id="items-count">0</span></div>
            </div>
        </div>
    </aside>
</main>
</div>
<script src="js/utils.js"></script>
<script>
    // API Configuration
    const API_BASE_URL = '/api';
    let currentUser = null;
    
    // Embedding Visualization State
    let canvas, ctx;
    let embeddingData = {
        user: null,
        items: [],
        interactedItems: [], // Items user has interacted with (keep permanently)
        interactions: [],
        otherUsers: [], // Other users who interacted with same items
        otherUsersInteractions: [] // Interactions of other users with same items
    };
    let interactionCount = 0;

    /**
     * Check if user is logged in
     */
    function checkLogin() {
        const userStr = sessionStorage.getItem('currentUser');
        if (!userStr) {
            // Redirect to login
            window.location.href = '/login.html';
            return false;
        }
        
        currentUser = JSON.parse(userStr);
        
        // Update UI with user info
        const usernameDisplay = document.getElementById('username-display');
        if (usernameDisplay) {
            usernameDisplay.textContent = currentUser.username || 'User';
        }
        
        console.log('âœ… Logged in as:', currentUser.username, '(ID:', currentUser._id, ')');
        return true;
    }

    /**
     * Logout function
     */
    function logout() {
        sessionStorage.removeItem('currentUser');
        window.location.href = '/login.html';
    }

    /**
     * Fetch recommended items for current user (exclude interacted items)
     */
    async function fetchRecommendations(limit = 50) {
        try {
            const response = await fetch(`${API_BASE_URL}/recommend/${currentUser._id}?limit=${limit}`);
            const data = await response.json();
            
            if (!data.success) {
                throw new Error(data.error || 'Failed to fetch recommendations');
            }
            
            console.log(`âœ… Got ${data.count} recommendations (excluding interacted items)`);
            return data.recommendations;
        } catch (error) {
            console.error('Error fetching recommendations:', error);
            // Fallback to all items
            return fetchItems(limit);
        }
    }

    /**
     * Fetch all items from database (fallback)
     */
    async function fetchItems(limit = 50) {
        try {
            const response = await fetch(`${API_BASE_URL}/items?limit=${limit}`);
            const data = await response.json();
            
            if (!data.success) {
                throw new Error(data.error || 'Failed to fetch items');
            }
            
            return data.items;
        } catch (error) {
            console.error('Error fetching items:', error);
            throw error;
        }
    }

    /**
     * Log interaction to backend
     */
    async function logInteraction(itemId, actionType) {
        try {
            const response = await fetch(`${API_BASE_URL}/interact`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    userId: currentUser._id,
                    itemId: itemId,
                    type: actionType
                })
            });
            
            const data = await response.json();
            
            if (data.success) {
                console.log(`âœ… Interaction logged: ${currentUser.username} -> ${itemId} (${actionType})`);
            }
        } catch (error) {
            console.error('Error logging interaction:', error);
        }
    }

    /**
     * Render items to grid
     */
    function renderItems(items) {
        const grid = document.getElementById('items-grid');
        grid.innerHTML = '';
        
        if (!items || items.length === 0) {
            grid.innerHTML = '<p class="col-span-3 text-center text-slate-500 py-8">No items found</p>';
            grid.classList.remove('hidden');
            document.getElementById('loading').classList.add('hidden');
            return;
        }

        items.forEach(item => {
            const card = document.createElement('div');
            card.className = "bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden hover:shadow-md transition";
            
            const imageUrl = item.imageUrl || item.img || 
                `https://images.unsplash.com/photo-1620712943543-bcc4688e7485?w=500&auto=format&fit=crop`;
            
            const category = item.category || item.cat || 'General';
            const title = item.title || `Item ${item._id}`;
            const prediction = item.predictionScore || Math.floor(Math.random() * 30 + 65);
            
            // Determine prediction color based on score
            let predictionColor = 'bg-green-500';
            if (prediction >= 85) predictionColor = 'bg-emerald-500';
            else if (prediction >= 75) predictionColor = 'bg-green-500';
            else if (prediction >= 65) predictionColor = 'bg-yellow-500';
            
            card.innerHTML = `
                <div class="h-40 bg-slate-200 relative">
                    <img src="${imageUrl}" class="w-full h-full object-cover" 
                         onerror="this.src='https://via.placeholder.com/500x300?text=${encodeURIComponent(title)}'">
                    <span class="absolute bottom-2 left-2 bg-white/90 px-2 py-1 text-xs font-bold rounded">${category}</span>
                    <div class="absolute top-2 right-2 ${predictionColor} text-white px-2 py-1 text-xs font-bold rounded-lg shadow-lg flex items-center gap-1">
                        <span class="material-symbols-outlined text-sm">trending_up</span>
                        <span>${prediction}%</span>
                    </div>
                </div>
                <div class="p-4">
                    <h3 class="font-bold text-slate-800 mb-2 line-clamp-2">${title}</h3>
                    ${item.description ? `
                        <p class="text-xs text-slate-500 mb-3 line-clamp-2">${item.description}</p>
                    ` : ''}
                    <div class="flex gap-2 mt-4">
                        <button class="flex-1 py-1.5 text-xs font-bold text-blue-600 bg-blue-50 rounded hover:bg-blue-100 transition flex items-center justify-center gap-1" 
                                onclick="handleClick('${item._id}', '${title.replace(/'/g, "\\'")}')">
                            <span class="material-symbols-outlined text-base">touch_app</span>
                            Click
                        </button>
                        <button class="flex-1 py-1.5 text-xs font-bold text-pink-600 bg-pink-50 rounded hover:bg-pink-100 transition flex items-center justify-center gap-1" 
                                onclick="handleLike('${item._id}', '${title.replace(/'/g, "\\'")}')">
                            <span class="material-symbols-outlined text-base">favorite</span>
                            Like
                        </button>
                        <button class="flex-1 py-1.5 text-xs font-bold text-purple-600 bg-purple-50 rounded hover:bg-purple-100 transition flex items-center justify-center gap-1" 
                                onclick="handleShare('${item._id}', '${title.replace(/'/g, "\\'")}')">
                            <span class="material-symbols-outlined text-base">share</span>
                            Share
                        </button>
                    </div>
                </div>
            `;
            grid.appendChild(card);
        });
        
        grid.classList.remove('hidden');
        document.getElementById('loading').classList.add('hidden');
    }

    /**
     * Handle Click action (renamed from View)
     */
    async function handleClick(itemId, title) {
        await logInteraction(itemId, 'click');
        console.log(`ðŸ‘† Clicked: ${title}`);
        
        // Add to visualization immediately (show line)
        addInteractionToVisualization(itemId, 'click');
        
        // Wait for backend to update embedding, then refresh
        setTimeout(() => refreshRecommendations(), 1500);
    }

    /**
     * Handle Like action
     */
    async function handleLike(itemId, title) {
        await logInteraction(itemId, 'like');
        
        // Add to visualization immediately (show line)
        addInteractionToVisualization(itemId, 'like');
        
        // Visual feedback
        const notification = document.createElement('div');
        notification.className = 'fixed top-20 right-6 bg-pink-500 text-white px-4 py-3 rounded-lg shadow-lg flex items-center gap-2 z-50 animate-bounce';
        notification.innerHTML = `
            <span class="material-symbols-outlined">favorite</span>
            <span>Liked: ${title}</span>
        `;
        document.body.appendChild(notification);
        
        setTimeout(() => notification.remove(), 2000);
        
        // Wait for backend to update embedding, then refresh
        setTimeout(() => refreshRecommendations(), 1500);
    }

    /**
     * Handle Share action
     */
    async function handleShare(itemId, title) {
        await logInteraction(itemId, 'share');
        
        // Add to visualization immediately (show line)
        addInteractionToVisualization(itemId, 'share');
        
        // Visual feedback
        const notification = document.createElement('div');
        notification.className = 'fixed top-20 right-6 bg-purple-500 text-white px-4 py-3 rounded-lg shadow-lg flex items-center gap-2 z-50';
        notification.innerHTML = `
            <span class="material-symbols-outlined">share</span>
            <span>Shared: ${title}</span>
        `;
        document.body.appendChild(notification);
        
        setTimeout(() => notification.remove(), 2000);
        
        console.log(`ðŸ”— Shared: ${title}`);
        
        // Wait for backend to update embedding, then refresh
        setTimeout(() => refreshRecommendations(), 1500);
    }

    /**
     * Refresh recommendations
     */
    async function refreshRecommendations() {
        try {
            document.getElementById('loading').classList.remove('hidden');
            document.getElementById('items-grid').classList.add('hidden');
            
            const items = await fetchRecommendations(50);
            renderItems(items);
            
            // Re-fetch user embedding and update visualization with new items
            await updateVisualizationAfterInteraction(items);
            
            console.log(`ðŸ”„ Refreshed: ${items.length} new recommendations`);
        } catch (error) {
            console.error('Error refreshing recommendations:', error);
        }
    }

    /**
     * Show error message
     */
    function showError(message) {
        document.getElementById('loading').classList.add('hidden');
        document.getElementById('error').classList.remove('hidden');
        document.getElementById('error-message').textContent = message;
    }

    /**
     * Initialize - Load items on page load
     */
    async function init() {
        // Check login first
        if (!checkLogin()) {
            return;
        }
        
        // Initialize canvas
        initCanvas();
        
        try {
            // Fetch personalized recommendations (excluding interacted items)
            const items = await fetchRecommendations(50);
            renderItems(items);
            
            // Initialize visualization with user and items
            await initializeVisualization(items);
            
            console.log(`âœ… Loaded ${items.length} recommended items for ${currentUser.username}`);
        } catch (error) {
            console.error('Initialization error:', error);
            showError(error.message || 'Failed to load recommendations. Please try again later.');
        }
    }

    // Start when page loads
    window.addEventListener('DOMContentLoaded', init);

    /**
     * ========================================
     * EMBEDDING VISUALIZATION FUNCTIONS
     * ========================================
     */

    /**
     * Initialize canvas
     */
    function initCanvas() {
        canvas = document.getElementById('embedding-canvas');
        if (!canvas) return;
        
        ctx = canvas.getContext('2d');
        
        // Set canvas size to match container
        const resizeCanvas = () => {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            redrawCanvas();
        };
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
    }

    /**
     * PCA: Reduce embedding from 64D to 2D
     */
    function pcaReduce(embeddings) {
        if (!embeddings || embeddings.length === 0) return [];
        
        // Simple PCA: Use first 2 principal components
        // For real implementation, we just take weighted sum of dimensions
        return embeddings.map(emb => {
            if (!emb || emb.length === 0) return { x: 0, y: 0 };
            
            // Project to 2D using simple linear combination
            const x = emb.slice(0, 32).reduce((sum, v, i) => sum + v * Math.cos(i * 0.1), 0);
            const y = emb.slice(32, 64).reduce((sum, v, i) => sum + v * Math.sin(i * 0.1), 0);
            
            return { x, y };
        });
    }

    /**
     * Normalize 2D points to canvas coordinates
     */
    function normalizePoints(points) {
        if (points.length === 0) return [];
        
        const xs = points.map(p => p.x);
        const ys = points.map(p => p.y);
        const minX = Math.min(...xs);
        const maxX = Math.max(...xs);
        const minY = Math.min(...ys);
        const maxY = Math.max(...ys);
        
        const rangeX = maxX - minX || 1;
        const rangeY = maxY - minY || 1;
        
        const padding = 40;
        const width = canvas.width / window.devicePixelRatio - 2 * padding;
        const height = canvas.height / window.devicePixelRatio - 2 * padding;
        
        return points.map(p => ({
            x: padding + ((p.x - minX) / rangeX) * width,
            y: padding + ((p.y - minY) / rangeY) * height
        }));
    }

    /**
     * Initialize visualization with user and recommended items
     */
    async function initializeVisualization(items) {
        try {
            // Fetch user data with embedding
            const userResponse = await fetch(`${API_BASE_URL}/users?embedding=true`);
            const usersData = await userResponse.json();
            const user = usersData.users.find(u => u._id === currentUser._id);
            
            if (!user || !user.embedding) {
                console.warn('User has no embedding data');
                return;
            }
            
            embeddingData.user = user;
            // embeddingData.items = items.filter(item => item.embedding && item.embedding.length > 0);
            
            // Load interactions from database
            await loadInteractionsFromDatabase();
            
            console.log(`ðŸ“Š Visualizing: 1 user + ${embeddingData.interactedItems.length} interacted items + ${embeddingData.items.length} recommended items`);
            
            redrawCanvas();
            updateStats();
        } catch (error) {
            console.error('Error initializing visualization:', error);
        }
    }
    
    /**
     * Load user's interactions from database
     */
    async function loadInteractionsFromDatabase() {
        try {
            // Fetch all interactions for current user
            const response = await fetch(`${API_BASE_URL}/interactions/${currentUser._id}`);
            const data = await response.json();
            
            if (!data.success || !data.interactions) {
                console.log('No interactions found');
                return;
            }
            
            console.log(`ðŸ“¥ Loaded ${data.interactions.length} interactions from database`);
            
            // Reset interaction count
            interactionCount = data.interactions.length;
            
            // Store interactions
            embeddingData.interactions = data.interactions.map(interaction => ({
                itemId: interaction.itemId,
                type: interaction.type,
                timestamp: new Date(interaction.timestamp).getTime()
            }));
            
            // Fetch full item data for interacted items
            const interactedItemIds = [...new Set(data.interactions.map(i => i.itemId))];
            
            console.log(`ðŸ“¥ Found ${interactedItemIds.length} unique interacted items:`, interactedItemIds);
            
            if (interactedItemIds.length > 0) {
                const itemsResponse = await fetch(`${API_BASE_URL}/items?limit=1000&embedding=true`);
                const itemsData = await itemsResponse.json();
                
                // Find all interacted items with embeddings
                embeddingData.interactedItems = itemsData.items.filter(item => {
                    const hasInteraction = interactedItemIds.includes(item._id.toString());
                    const hasEmbedding = item.embedding && item.embedding.length > 0;
                    return hasInteraction && hasEmbedding;
                });
                
                console.log(`ðŸ“Œ Loaded ${embeddingData.interactedItems.length} interacted items with embeddings`);
                
                if (embeddingData.interactedItems.length !== interactedItemIds.length) {
                    console.warn(`âš ï¸ Some interacted items missing embeddings: ${interactedItemIds.length - embeddingData.interactedItems.length}`);
                }
                
                // Load other users for all interacted items
                for (const itemId of interactedItemIds) {
                    await loadOtherUsersForItem(itemId);
                }
            }
            
        } catch (error) {
            console.error('Error loading interactions:', error);
        }
    }

    

    /**
     * Add interaction to visualization
     */
    async function addInteractionToVisualization(itemId, type) {
        // Find the item in current items
        const item = embeddingData.items.find(i => i._id === itemId);
        
        if (item) {
            // Add to interacted items if not already there
            const alreadyInteracted = embeddingData.interactedItems.some(i => i._id === itemId);
            if (!alreadyInteracted) {
                embeddingData.interactedItems.push(item);
                console.log(`ðŸ“Œ Item added to interacted list: ${item.title}`);
                
                // Load other users who interacted with this item
                await loadOtherUsersForItem(itemId);
            }
        }
        
        // Add interaction
        embeddingData.interactions.push({
            itemId,
            type,
            timestamp: Date.now()
        });
        
        interactionCount++;
        redrawCanvas();
        updateStats();
    }
    
    /**
     * Load other users who have interacted with a specific item
     */
    async function loadOtherUsersForItem(itemId) {
        try {
            // Fetch all interactions for this item
            const response = await fetch(`${API_BASE_URL}/interactions/item/${itemId}`);
            const data = await response.json();
            
            if (!data.success || !data.interactions || data.interactions.length === 0) {
                console.log(`No other users found for item ${itemId}`);
                return;
            }
            
            // Get unique user IDs (excluding current user)
            const otherUserIds = [...new Set(
                data.interactions
                    .map(i => i.userId)
                    .filter(uid => uid !== currentUser._id)
            )];
            
            if (otherUserIds.length === 0) {
                console.log(`Only current user has interacted with item ${itemId}`);
                return;
            }
            
            console.log(`ðŸ‘¥ Found ${otherUserIds.length} other users who interacted with this item`);
            
            // Fetch user data with embeddings
            const usersResponse = await fetch(`${API_BASE_URL}/users?embedding=true`);
            const usersData = await usersResponse.json();
            
            // Filter to get other users with embeddings
            const newUsers = usersData.users.filter(user => 
                otherUserIds.includes(user._id) && 
                user.embedding && 
                user.embedding.length > 0 &&
                !embeddingData.otherUsers.some(u => u._id === user._id) // Not already added
            );
            
            // Add to other users list
            embeddingData.otherUsers.push(...newUsers);
            
            // Add their interactions with this item
            data.interactions.forEach(interaction => {
                if (interaction.userId !== currentUser._id) {
                    embeddingData.otherUsersInteractions.push({
                        userId: interaction.userId,
                        itemId: interaction.itemId,
                        type: interaction.type,
                        timestamp: new Date(interaction.timestamp).getTime()
                    });
                }
            });
            
            console.log(`âœ… Added ${newUsers.length} other users to visualization`);
            
        } catch (error) {
            console.error('Error loading other users:', error);
        }
    }
    
    /**
     * Update visualization after interaction (re-fetch user embedding and new items)
     */
    async function updateVisualizationAfterInteraction(newItems) {
        try {
            // Re-fetch user with updated embedding
            const userResponse = await fetch(`${API_BASE_URL}/users?embedding=true`);
            const usersData = await userResponse.json();
            const user = usersData.users.find(u => u._id === currentUser._id);
            
            if (user && user.embedding) {
                embeddingData.user = user;
                console.log('ðŸ“Š User embedding updated - position will shift');
            }
            
            // Filter new items to only those with embeddings
            const newItemsWithEmbedding = newItems.filter(item => item.embedding && item.embedding.length > 0);
            
            if (newItemsWithEmbedding.length === 0) {
                console.warn('No items with embeddings');
                return;
            }
            
            // Calculate dot product for each new item with user
            const itemsWithScore = newItemsWithEmbedding.map(item => {
                const dotProduct = calculateDotProduct(user.embedding, item.embedding);
                return {
                    ...item,
                    similarity: dotProduct
                };
            });
            
            // Sort by similarity (highest first) and take top 10
            itemsWithScore.sort((a, b) => b.similarity - a.similarity);
            const top10Items = itemsWithScore.slice(0, 10);
            
            // Update recommended items (closest 10 to user)
            embeddingData.items = top10Items;
            
            // Note: embeddingData.interactedItems is preserved (never cleared)
            // Note: embeddingData.interactions is preserved (keep history)
            
            console.log(`ðŸ“Š Visualization updated: user moved, showing ${embeddingData.interactedItems.length} interacted + ${embeddingData.items.length} closest items`);
            
            redrawCanvas();
            updateStats();
        } catch (error) {
            console.error('Error updating visualization:', error);
        }
    }
    

</script>
</body>
</html>